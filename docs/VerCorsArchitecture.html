---
layout: default2
title: VerCors Overview--Architecture 
---

		<!-- Main -->
			<div id="main" class="wrapper style1">
				<div class="container">
					<section>
						<header class="major">
						<h2><strong style="color:#3ac984"> The VerCors Tool Architecture</strong></h2>
							<span class="byline">Verifying the correctness of Concurrent and Distributed Software</span>
						</header>
				<p style="text-align:justify"> VerCors transforms the verification problem of programs written in a high-level programming language into a verification problem in the intermediate language of <a href="http://www.pm.inf.ethz.ch/research/viper.html" style="color:blue">Viper</a>. It builds on top of existing verification technology, notably the <a href="http://www.pm.inf.ethz.ch/research/viper.html" style="color:blue">Viper</a> framework. The VerCors tool set reuses existing verification technology, notably the Viper framework, by transforming the verification problem of programs written in a high-level programming language into a verification problem in the intermediate language of Viper. It supports the verification of functional correctness of a program using a heterogeneous concurrency model, and of kernels using barriers and atomic operations for synchronisation between threads and workgroups. It can also how the technology is used to reason about compiler directives for parallelisation. The overall architecture of the VerCors tool set is presented in the following figure.
	<a href="#" class="image feature"><img src="{{"/images/VerCors2.png" | prepend: site.baseurl }}" alt="The VerCors Tool Architecture"></a>
Our goals are not so much to develop new program verification technology, but rather to make existing program verification technology usable for high-level program languages and advanced language features. This is reflected in the design of the VerCors tool set, which is implemented as a collection of compiler transformations. It takes as input a program in high-level program language, annotated with JML-style specifications, and transforms this into a collection of verification problems for an intermediate verification language.</p>
<h3>Front-end languages </h3> 
<p style="text-align:justify"> The current main input languages for VerCors are Java, OpenCL and PVL: it supports reasoning about all the main concurrency-related features of these languages. Moreover, a commonly used subset of OpenMP, essentially characterising deterministic parallel programming, is supported. PVL is a procedural toy language used for teaching and quick prototyping of new verification features. For Java, we only provide limited support related to inheritance, as this is orthogonal to concurrency-related aspects. The support for OpenCL only covers the verification of kernels, including barrier synchronisation and atomic operations, It does not support reasoning about host code yet. However, supporting those features of Java and OpenCL would mainly be an engineering effort (in particular, PVL already has support to reason about host code). Due to its modular design, the VerCors toolset can be extended with any (pointer) language having parallel or concurrent language constructs like: dynamic thread creation, deterministic parallelism, and SIMD-like parallelism.</p>
<h3>Back-ends</h3> 
<p style="text-align:justify"> Currently the Viper tool set is the main back-end of VerCors. Viper supports the intermediate verification language Silver, which provides support to reason about programs with persistent mutable state, annotated with separation logic-style specifications. The Viper tool set provides two styles of reasoning, using verification conditions generation (via Boogie), and by symbolic execution. The symbolic execution engine is the most powerful, and provides support for features such as quantified permissions, which we heavily rely upon. In earlier versions of VerCors, we used Chalice as the main back end, but its functionality is subsumed by Viper.
</p>

											
				</div>
			</div>
